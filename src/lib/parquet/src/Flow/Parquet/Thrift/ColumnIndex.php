<?php

declare(strict_types=1);
namespace Flow\Parquet\Thrift;

/**
 * Autogenerated by Thrift Compiler (0.18.1).
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *
 *  @generated
 */
use Thrift\Exception\{TProtocolException};
use Thrift\Type\{TType};

/**
 * Optional statistics for each data page in a ColumnChunk.
 *
 * Forms part the page index, along with OffsetIndex.
 *
 * If this structure is present, OffsetIndex must also be present.
 *
 * For each field in this structure, <field>[i] refers to the page at
 * OffsetIndex.page_locations[i]
 */
class ColumnIndex
{
    public static $_TSPEC = [
        1 => [
            'var' => 'null_pages',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::BOOL,
            'elem' => [
                'type' => TType::BOOL,
            ],
        ],
        2 => [
            'var' => 'min_values',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => [
                'type' => TType::STRING,
            ],
        ],
        3 => [
            'var' => 'max_values',
            'isRequired' => true,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => [
                'type' => TType::STRING,
            ],
        ],
        4 => [
            'var' => 'boundary_order',
            'isRequired' => true,
            'type' => TType::I32,
            'class' => '\Flow\Parquet\Thrift\BoundaryOrder',
        ],
        5 => [
            'var' => 'null_counts',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => [
                'type' => TType::I64,
            ],
        ],
        6 => [
            'var' => 'repetition_level_histograms',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => [
                'type' => TType::I64,
            ],
        ],
        7 => [
            'var' => 'definition_level_histograms',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => [
                'type' => TType::I64,
            ],
        ],
    ];

    public static $isValidate = false;

    /**
     * Stores whether both min_values and max_values are ordered and if so, in
     * which direction. This allows readers to perform binary searches in both
     * lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
     * if the lists are ordered.
     *
     * @var int
     */
    public $boundary_order;

    /**
     * Same as repetition_level_histograms except for definitions levels.
     *
     * @var array<int>
     */
    public $definition_level_histograms;

    /**
     * @var array<string>
     */
    public $max_values;

    /**
     * Two lists containing lower and upper bounds for the values of each page
     * determined by the ColumnOrder of the column. These may be the actual
     * minimum and maximum values found on a page, but can also be (more compact)
     * values that do not exist on a page. For example, instead of storing ""Blart
     * Versenwald III", a writer may set min_values[i]="B", max_values[i]="C".
     * Such more compact values must still be valid values within the column's
     * logical type. Readers must make sure that list entries are populated before
     * using them by inspecting null_pages.
     *
     * @var array<string>
     */
    public $min_values;

    /**
     * A list containing the number of null values for each page.
     *
     * Writers SHOULD always write this field even if no null values
     * are present or the column is not nullable.
     * Readers MUST distinguish between null_counts not being present
     * and null_count being 0.
     * If null_counts are not present, readers MUST NOT assume all
     * null counts are 0.
     *
     * @var array<int>
     */
    public $null_counts;

    /**
     * A list of Boolean values to determine the validity of the corresponding
     * min and max values. If true, a page contains only null values, and writers
     * have to set the corresponding entries in min_values and max_values to
     * byte[0], so that all lists have the same length. If false, the
     * corresponding entries in min_values and max_values must be valid.
     *
     * @var array<bool>
     */
    public $null_pages;

    /**
     * Contains repetition level histograms for each page
     * concatenated together.  The repetition_level_histogram field on
     * SizeStatistics contains more details.
     *
     * When present the length should always be (number of pages *
     * (max_repetition_level + 1)) elements.
     *
     * Element 0 is the first element of the histogram for the first page.
     * Element (max_repetition_level + 1) is the first element of the histogram
     * for the second page.
     *
     * @var array<int>
     */
    public $repetition_level_histograms;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['null_pages'])) {
                $this->null_pages = $vals['null_pages'];
            }

            if (isset($vals['min_values'])) {
                $this->min_values = $vals['min_values'];
            }

            if (isset($vals['max_values'])) {
                $this->max_values = $vals['max_values'];
            }

            if (isset($vals['boundary_order'])) {
                $this->boundary_order = $vals['boundary_order'];
            }

            if (isset($vals['null_counts'])) {
                $this->null_counts = $vals['null_counts'];
            }

            if (isset($vals['repetition_level_histograms'])) {
                $this->repetition_level_histograms = $vals['repetition_level_histograms'];
            }

            if (isset($vals['definition_level_histograms'])) {
                $this->definition_level_histograms = $vals['definition_level_histograms'];
            }
        }
    }

    public function getName()
    {
        return 'ColumnIndex';
    }

    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);

        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);

            if ($ftype == TType::STOP) {
                break;
            }

            switch ($fid) {
                case 1:
                    if ($ftype == TType::LST) {
                        $this->null_pages = [];
                        $_size77 = 0;
                        $_etype80 = 0;
                        $xfer += $input->readListBegin($_etype80, $_size77);

                        for ($_i81 = 0; $_i81 < $_size77; $_i81++) {
                            $elem82 = null;
                            $xfer += $input->readBool($elem82);
                            $this->null_pages[] = $elem82;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->min_values = [];
                        $_size83 = 0;
                        $_etype86 = 0;
                        $xfer += $input->readListBegin($_etype86, $_size83);

                        for ($_i87 = 0; $_i87 < $_size83; $_i87++) {
                            $elem88 = null;
                            $xfer += $input->readString($elem88);
                            $this->min_values[] = $elem88;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 3:
                    if ($ftype == TType::LST) {
                        $this->max_values = [];
                        $_size89 = 0;
                        $_etype92 = 0;
                        $xfer += $input->readListBegin($_etype92, $_size89);

                        for ($_i93 = 0; $_i93 < $_size89; $_i93++) {
                            $elem94 = null;
                            $xfer += $input->readString($elem94);
                            $this->max_values[] = $elem94;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->boundary_order);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 5:
                    if ($ftype == TType::LST) {
                        $this->null_counts = [];
                        $_size95 = 0;
                        $_etype98 = 0;
                        $xfer += $input->readListBegin($_etype98, $_size95);

                        for ($_i99 = 0; $_i99 < $_size95; $_i99++) {
                            $elem100 = null;
                            $xfer += $input->readI64($elem100);
                            $this->null_counts[] = $elem100;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 6:
                    if ($ftype == TType::LST) {
                        $this->repetition_level_histograms = [];
                        $_size101 = 0;
                        $_etype104 = 0;
                        $xfer += $input->readListBegin($_etype104, $_size101);

                        for ($_i105 = 0; $_i105 < $_size101; $_i105++) {
                            $elem106 = null;
                            $xfer += $input->readI64($elem106);
                            $this->repetition_level_histograms[] = $elem106;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 7:
                    if ($ftype == TType::LST) {
                        $this->definition_level_histograms = [];
                        $_size107 = 0;
                        $_etype110 = 0;
                        $xfer += $input->readListBegin($_etype110, $_size107);

                        for ($_i111 = 0; $_i111 < $_size107; $_i111++) {
                            $elem112 = null;
                            $xfer += $input->readI64($elem112);
                            $this->definition_level_histograms[] = $elem112;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;

                default:
                    $xfer += $input->skip($ftype);

                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();

        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('ColumnIndex');

        if ($this->null_pages !== null) {
            if (!is_array($this->null_pages)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('null_pages', TType::LST, 1);
            $output->writeListBegin(TType::BOOL, count($this->null_pages));

            foreach ($this->null_pages as $iter113) {
                $xfer += $output->writeBool($iter113);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->min_values !== null) {
            if (!is_array($this->min_values)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('min_values', TType::LST, 2);
            $output->writeListBegin(TType::STRING, count($this->min_values));

            foreach ($this->min_values as $iter114) {
                $xfer += $output->writeString($iter114);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->max_values !== null) {
            if (!is_array($this->max_values)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('max_values', TType::LST, 3);
            $output->writeListBegin(TType::STRING, count($this->max_values));

            foreach ($this->max_values as $iter115) {
                $xfer += $output->writeString($iter115);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->boundary_order !== null) {
            $xfer += $output->writeFieldBegin('boundary_order', TType::I32, 4);
            $xfer += $output->writeI32($this->boundary_order);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->null_counts !== null) {
            if (!is_array($this->null_counts)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('null_counts', TType::LST, 5);
            $output->writeListBegin(TType::I64, count($this->null_counts));

            foreach ($this->null_counts as $iter116) {
                $xfer += $output->writeI64($iter116);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->repetition_level_histograms !== null) {
            if (!is_array($this->repetition_level_histograms)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('repetition_level_histograms', TType::LST, 6);
            $output->writeListBegin(TType::I64, count($this->repetition_level_histograms));

            foreach ($this->repetition_level_histograms as $iter117) {
                $xfer += $output->writeI64($iter117);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->definition_level_histograms !== null) {
            if (!is_array($this->definition_level_histograms)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('definition_level_histograms', TType::LST, 7);
            $output->writeListBegin(TType::I64, count($this->definition_level_histograms));

            foreach ($this->definition_level_histograms as $iter118) {
                $xfer += $output->writeI64($iter118);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();

        return $xfer;
    }
}
