<?php

declare(strict_types=1);
namespace Flow\Parquet\Thrift;

/**
 * Autogenerated by Thrift Compiler (0.18.1).
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *
 *  @generated
 */
use Thrift\Exception\{TProtocolException};
use Thrift\Type\{TType};

class PageHeader
{
    public static $_TSPEC = [
        1 => [
            'var' => 'type',
            'isRequired' => true,
            'type' => TType::I32,
            'class' => '\Flow\Parquet\Thrift\PageType',
        ],
        2 => [
            'var' => 'uncompressed_page_size',
            'isRequired' => true,
            'type' => TType::I32,
        ],
        3 => [
            'var' => 'compressed_page_size',
            'isRequired' => true,
            'type' => TType::I32,
        ],
        4 => [
            'var' => 'crc',
            'isRequired' => false,
            'type' => TType::I32,
        ],
        5 => [
            'var' => 'data_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DataPageHeader',
        ],
        6 => [
            'var' => 'index_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\IndexPageHeader',
        ],
        7 => [
            'var' => 'dictionary_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DictionaryPageHeader',
        ],
        8 => [
            'var' => 'data_page_header_v2',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DataPageHeaderV2',
        ],
    ];

    public static $isValidate = false;

    /**
     * Compressed (and potentially encrypted) page size in bytes, not including this header *.
     *
     * @var int
     */
    public $compressed_page_size;

    /**
     * The 32-bit CRC checksum for the page, to be be calculated as follows:
     *
     * - The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,
     *   the same as in e.g. GZip).
     * - All page types can have a CRC (v1 and v2 data pages, dictionary pages,
     *   etc.).
     * - The CRC is computed on the serialization binary representation of the page
     *   (as written to disk), excluding the page header. For example, for v1
     *   data pages, the CRC is computed on the concatenation of repetition levels,
     *   definition levels and column values (optionally compressed, optionally
     *   encrypted).
     * - The CRC computation therefore takes place after any compression
     *   and encryption steps, if any.
     *
     * If enabled, this allows for disabling checksumming in HDFS if only a few
     * pages need to be read.
     *
     * @var int
     */
    public $crc;

    /**
     * @var DataPageHeader
     */
    public $data_page_header;

    /**
     * @var DataPageHeaderV2
     */
    public $data_page_header_v2;

    /**
     * @var DictionaryPageHeader
     */
    public $dictionary_page_header;

    /**
     * @var IndexPageHeader
     */
    public $index_page_header;

    /**
     * the type of the page: indicates which of the *_header fields is set *.
     *
     * @var int
     */
    public $type;

    /**
     * Uncompressed page size in bytes (not including this header) *.
     *
     * @var int
     */
    public $uncompressed_page_size;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['type'])) {
                $this->type = $vals['type'];
            }

            if (isset($vals['uncompressed_page_size'])) {
                $this->uncompressed_page_size = $vals['uncompressed_page_size'];
            }

            if (isset($vals['compressed_page_size'])) {
                $this->compressed_page_size = $vals['compressed_page_size'];
            }

            if (isset($vals['crc'])) {
                $this->crc = $vals['crc'];
            }

            if (isset($vals['data_page_header'])) {
                $this->data_page_header = $vals['data_page_header'];
            }

            if (isset($vals['index_page_header'])) {
                $this->index_page_header = $vals['index_page_header'];
            }

            if (isset($vals['dictionary_page_header'])) {
                $this->dictionary_page_header = $vals['dictionary_page_header'];
            }

            if (isset($vals['data_page_header_v2'])) {
                $this->data_page_header_v2 = $vals['data_page_header_v2'];
            }
        }
    }

    public function getName()
    {
        return 'PageHeader';
    }

    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);

        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);

            if ($ftype == TType::STOP) {
                break;
            }

            switch ($fid) {
                case 1:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->type);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 2:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->uncompressed_page_size);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 3:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->compressed_page_size);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->crc);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 5:
                    if ($ftype == TType::STRUCT) {
                        $this->data_page_header = new DataPageHeader();
                        $xfer += $this->data_page_header->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 6:
                    if ($ftype == TType::STRUCT) {
                        $this->index_page_header = new IndexPageHeader();
                        $xfer += $this->index_page_header->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 7:
                    if ($ftype == TType::STRUCT) {
                        $this->dictionary_page_header = new DictionaryPageHeader();
                        $xfer += $this->dictionary_page_header->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 8:
                    if ($ftype == TType::STRUCT) {
                        $this->data_page_header_v2 = new DataPageHeaderV2();
                        $xfer += $this->data_page_header_v2->read($input);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;

                default:
                    $xfer += $input->skip($ftype);

                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();

        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('PageHeader');

        if ($this->type !== null) {
            $xfer += $output->writeFieldBegin('type', TType::I32, 1);
            $xfer += $output->writeI32($this->type);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->uncompressed_page_size !== null) {
            $xfer += $output->writeFieldBegin('uncompressed_page_size', TType::I32, 2);
            $xfer += $output->writeI32($this->uncompressed_page_size);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->compressed_page_size !== null) {
            $xfer += $output->writeFieldBegin('compressed_page_size', TType::I32, 3);
            $xfer += $output->writeI32($this->compressed_page_size);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->crc !== null) {
            $xfer += $output->writeFieldBegin('crc', TType::I32, 4);
            $xfer += $output->writeI32($this->crc);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->data_page_header !== null) {
            if (!is_object($this->data_page_header)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('data_page_header', TType::STRUCT, 5);
            $xfer += $this->data_page_header->write($output);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->index_page_header !== null) {
            if (!is_object($this->index_page_header)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('index_page_header', TType::STRUCT, 6);
            $xfer += $this->index_page_header->write($output);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->dictionary_page_header !== null) {
            if (!is_object($this->dictionary_page_header)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('dictionary_page_header', TType::STRUCT, 7);
            $xfer += $this->dictionary_page_header->write($output);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->data_page_header_v2 !== null) {
            if (!is_object($this->data_page_header_v2)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('data_page_header_v2', TType::STRUCT, 8);
            $xfer += $this->data_page_header_v2->write($output);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();

        return $xfer;
    }
}
