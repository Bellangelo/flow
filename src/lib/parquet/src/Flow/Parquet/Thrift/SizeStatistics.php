<?php

declare(strict_types=1);
namespace Flow\Parquet\Thrift;

/**
 * Autogenerated by Thrift Compiler (0.18.1).
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *
 *  @generated
 */
use Thrift\Exception\{TProtocolException};
use Thrift\Type\{TType};

/**
 * A structure for capturing metadata for estimating the unencoded,
 * uncompressed size of data written. This is useful for readers to estimate
 * how much memory is needed to reconstruct data in their memory model and for
 * fine grained filter pushdown on nested structures (the histograms contained
 * in this structure can help determine the number of nulls at a particular
 * nesting level and maximum length of lists).
 */
class SizeStatistics
{
    public static $_TSPEC = [
        1 => [
            'var' => 'unencoded_byte_array_data_bytes',
            'isRequired' => false,
            'type' => TType::I64,
        ],
        2 => [
            'var' => 'repetition_level_histogram',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => [
                'type' => TType::I64,
            ],
        ],
        3 => [
            'var' => 'definition_level_histogram',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => [
                'type' => TType::I64,
            ],
        ],
    ];

    public static $isValidate = false;

    /**
     * Same as repetition_level_histogram except for definition levels.
     *
     * This field may be omitted if max_definition_level is 0 or 1 without
     * loss of information.
     *
     * @var array<int>
     */
    public $definition_level_histogram;

    /**
     * When present, there is expected to be one element corresponding to each
     * repetition (i.e. size=max repetition_level+1) where each element
     * represents the number of times the repetition level was observed in the
     * data.
     *
     * This field may be omitted if max_repetition_level is 0 without loss
     * of information.
     *
     * @var array<int>
     */
    public $repetition_level_histogram;

    /**
     * The number of physical bytes stored for BYTE_ARRAY data values assuming
     * no encoding. This is exclusive of the bytes needed to store the length of
     * each byte array. In other words, this field is equivalent to the `(size
     * of PLAIN-ENCODING the byte array values) - (4 bytes * number of values
     * written)`. To determine unencoded sizes of other types readers can use
     * schema information multiplied by the number of non-null and null values.
     * The number of null/non-null values can be inferred from the histograms
     * below.
     *
     * For example, if a column chunk is dictionary-encoded with dictionary
     * ["a", "bc", "cde"], and a data page contains the indices [0, 0, 1, 2],
     * then this value for that data page should be 7 (1 + 1 + 2 + 3).
     *
     * This field should only be set for types that use BYTE_ARRAY as their
     * physical type.
     *
     * @var int
     */
    public $unencoded_byte_array_data_bytes;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['unencoded_byte_array_data_bytes'])) {
                $this->unencoded_byte_array_data_bytes = $vals['unencoded_byte_array_data_bytes'];
            }

            if (isset($vals['repetition_level_histogram'])) {
                $this->repetition_level_histogram = $vals['repetition_level_histogram'];
            }

            if (isset($vals['definition_level_histogram'])) {
                $this->definition_level_histogram = $vals['definition_level_histogram'];
            }
        }
    }

    public function getName()
    {
        return 'SizeStatistics';
    }

    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);

        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);

            if ($ftype == TType::STOP) {
                break;
            }

            switch ($fid) {
                case 1:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->unencoded_byte_array_data_bytes);
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->repetition_level_histogram = [];
                        $_size0 = 0;
                        $_etype3 = 0;
                        $xfer += $input->readListBegin($_etype3, $_size0);

                        for ($_i4 = 0; $_i4 < $_size0; $_i4++) {
                            $elem5 = null;
                            $xfer += $input->readI64($elem5);
                            $this->repetition_level_histogram[] = $elem5;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;
                case 3:
                    if ($ftype == TType::LST) {
                        $this->definition_level_histogram = [];
                        $_size6 = 0;
                        $_etype9 = 0;
                        $xfer += $input->readListBegin($_etype9, $_size6);

                        for ($_i10 = 0; $_i10 < $_size6; $_i10++) {
                            $elem11 = null;
                            $xfer += $input->readI64($elem11);
                            $this->definition_level_histogram[] = $elem11;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }

                    break;

                default:
                    $xfer += $input->skip($ftype);

                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();

        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('SizeStatistics');

        if ($this->unencoded_byte_array_data_bytes !== null) {
            $xfer += $output->writeFieldBegin('unencoded_byte_array_data_bytes', TType::I64, 1);
            $xfer += $output->writeI64($this->unencoded_byte_array_data_bytes);
            $xfer += $output->writeFieldEnd();
        }

        if ($this->repetition_level_histogram !== null) {
            if (!is_array($this->repetition_level_histogram)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('repetition_level_histogram', TType::LST, 2);
            $output->writeListBegin(TType::I64, count($this->repetition_level_histogram));

            foreach ($this->repetition_level_histogram as $iter12) {
                $xfer += $output->writeI64($iter12);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }

        if ($this->definition_level_histogram !== null) {
            if (!is_array($this->definition_level_histogram)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('definition_level_histogram', TType::LST, 3);
            $output->writeListBegin(TType::I64, count($this->definition_level_histogram));

            foreach ($this->definition_level_histogram as $iter13) {
                $xfer += $output->writeI64($iter13);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();

        return $xfer;
    }
}
